<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTF Rankings</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .category-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .category-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            background: #e0e0e0;
            color: #333;
        }

        .category-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.05);
        }

        .category-btn:hover {
            transform: translateY(-2px);
        }

        .question {
            text-align: center;
            font-size: 1.8em;
            margin-bottom: 30px;
            color: #333;
            font-weight: 600;
        }

        .comparison-container {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .member-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            width: 280px;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .member-card:hover {
            transform: translateY(-10px);
            border-color: #667eea;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .member-card.selected {
            border-color: #4caf50;
            background: #f1f8e9;
        }

        .member-card.not-selected {
            border-color: #f44336;
            background: #ffebee;
        }

        .member-image {
            width: 100%;
            height: 250px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .member-name {
            text-align: center;
            font-size: 1.4em;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .member-score {
            text-align: center;
            font-size: 1.1em;
            color: #666;
        }

        .score-change {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 10px;
            min-height: 30px;
        }

        .score-increase {
            color: #4caf50;
        }

        .score-decrease {
            color: #f44336;
        }

        .skip-btn {
            display: block;
            margin: 30px auto;
            padding: 15px 40px;
            background: #757575;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .skip-btn:hover {
            transform: scale(1.05);
            background: #616161;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .comparison-count {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RTF Rankings</h1>
        
        <div class="category-selector">
            <button class="category-btn active" data-category="random">Random</button>
            <button class="category-btn" data-category="rizz">Rizz</button>
            <button class="category-btn" data-category="tizz">Tizz</button>
            <button class="category-btn" data-category="freak">Freak</button>
        </div>

        <div class="question" id="question">Who has more Rizz?</div>

        <div class="comparison-container" id="comparisonContainer">
            <!-- Cards will be inserted here -->
        </div>

        <button class="skip-btn" id="skipBtn">Skip Comparison</button>

        <div class="comparison-count" id="comparisonCount">Comparisons: 0</div>
    </div>

    <script>
        // ================================
        // SUPABASE CONFIGURATION
        // ================================
        // Get these values from your Supabase dashboard:
        // 1. Go to: https://supabase.com/dashboard/project/YOUR_PROJECT/settings/api
        // 2. Copy "Project URL" and paste below
        // 3. Copy "anon public" key and paste below
        
        const SUPABASE_URL = 'https://cxytmlxqoficotadtmab.supabase.co';  // e.g., 'https://xxxxxxxxxxxxx.supabase.co'
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN4eXRtbHhxb2ZpY290YWR0bWFiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MDcyMzksImV4cCI6MjA3ODM4MzIzOX0.Bx95F7ufVJmLUlJmwH4zvNdE5EmbGsD8GIwmMW0flbc';  // Long string starting with 'eyJ...'
        
        // Check if Supabase is configured
        const isSupabaseConfigured = SUPABASE_URL !== 'YOUR_SUPABASE_URL_HERE' && 
                                     SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY_HERE';
        
        // Initialize Supabase client (only if configured)
        let supabase = null;
        if (isSupabaseConfigured) {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('✅ Supabase connected');
            } catch (err) {
                console.error('Failed to initialize Supabase:', err);
            }
        } else {
            console.warn('⚠️ Supabase not configured - running in local mode. Ratings will not persist.');
        }
        
        // ================================
        // MEMBER DATA
        // ================================
        // Member data (first 10 entries)
        const members = {
            "Aiden Suganuma": "https://www.thecube.llc/static/media/aidensuganuma.3126d63249c98b402919.jpg",
            "Alex Boniske": "https://www.thecube.llc/static/media/alexboniske.c958ca550435720511aa.jpg",
            "Alexis Fox": "https://www.thecube.llc/static/media/alexisfox.9fddedf46775b7a836ca.jpg",
            "Avrick Altmann": "https://www.thecube.llc/static/media/avrickaltmann.2962baac481c96d2e2a3.jpg",
            "Brian Mason": "https://www.thecube.llc/static/media/brianmason.1d754f5b7455d04cb69d.jpg",
            "Brianna Yang": "https://www.thecube.llc/static/media/briannayang.b1a6cc543f582a9ed89f.jpg",
            "Claire Chang": "https://www.thecube.llc/static/media/clairechang.0ba7a8a19b6658fc97d4.jpg",
            "Jane Shin": "https://www.thecube.llc/static/media/janeshin.9c11a60627771be1c29c.jpg",
            "Jonah Stein": "https://www.thecube.llc/static/media/jonahstein.3b2666663214205c61a9.jpg",
            "Julia Chen": "https://www.thecube.llc/static/media/juliachen.3e523ce7d5d895f59168.jpg"
        };

        // Glicko-2 implementation
        class Glicko2 {
            constructor() {
                this.tau = 0.5; // System constant
                this.epsilon = 0.000001;
            }

            scale(rating) {
                return (rating - 1500) / 173.7178;
            }

            unscale(rating) {
                return rating * 173.7178 + 1500;
            }

            g(rd) {
                return 1 / Math.sqrt(1 + 3 * rd * rd / (Math.PI * Math.PI));
            }

            E(mu, mu_j, rd_j) {
                return 1 / (1 + Math.exp(-this.g(rd_j) * (mu - mu_j)));
            }

            updateRating(rating, rd, volatility, opponents, outcomes) {
                const mu = this.scale(rating);
                const phi = rd / 173.7178;
                
                let v_inv = 0;
                let delta = 0;

                for (let i = 0; i < opponents.length; i++) {
                    const mu_j = this.scale(opponents[i].rating);
                    const phi_j = opponents[i].rd / 173.7178;
                    const outcome = outcomes[i];
                    
                    const g_phi_j = this.g(phi_j);
                    const E_val = this.E(mu, mu_j, phi_j);
                    
                    v_inv += g_phi_j * g_phi_j * E_val * (1 - E_val);
                    delta += g_phi_j * (outcome - E_val);
                }

                const v = 1 / v_inv;
                delta *= v;

                // Update volatility
                const a = Math.log(volatility * volatility);
                const f = (x) => {
                    const exp_x = Math.exp(x);
                    const phi_sq = phi * phi;
                    const delta_sq = delta * delta;
                    const v_plus = v + exp_x;
                    
                    return (exp_x * (delta_sq - phi_sq - v - exp_x)) / 
                           (2 * v_plus * v_plus) - 
                           (x - a) / (this.tau * this.tau);
                };

                let A = a;
                let B;
                
                if (delta * delta > phi * phi + v) {
                    B = Math.log(delta * delta - phi * phi - v);
                } else {
                    let k = 1;
                    while (f(a - k * this.tau) < 0) {
                        k++;
                    }
                    B = a - k * this.tau;
                }

                let f_A = f(A);
                let f_B = f(B);

                while (Math.abs(B - A) > this.epsilon) {
                    const C = A + (A - B) * f_A / (f_B - f_A);
                    const f_C = f(C);

                    if (f_C * f_B < 0) {
                        A = B;
                        f_A = f_B;
                    } else {
                        f_A = f_A / 2;
                    }

                    B = C;
                    f_B = f_C;
                }

                const new_volatility = Math.exp(A / 2);
                
                // Update rating deviation
                const phi_star = Math.sqrt(phi * phi + new_volatility * new_volatility);
                const new_phi = 1 / Math.sqrt(1 / (phi_star * phi_star) + 1 / v);
                
                // Update rating
                const new_mu = mu + new_phi * new_phi * delta / v;
                
                return {
                    rating: this.unscale(new_mu),
                    rd: new_phi * 173.7178,
                    volatility: new_volatility
                };
            }
        }

        // ================================
        // SUPABASE DATABASE FUNCTIONS
        // ================================
        
        // Initialize ratings for all members (local cache)
        const ratings = {};
        const categories = ['rizz', 'tizz', 'freak'];
        
        // Initialize default ratings
        for (const member in members) {
            ratings[member] = {};
            for (const category of categories) {
                ratings[member][category] = {
                    rating: 1500,
                    rd: 350,
                    volatility: 0.06
                };
            }
        }

        // Load ratings from Supabase
        async function loadRatings() {
            if (!supabase) {
                console.log('Supabase not configured - using default ratings');
                return;
            }
            
            try {
                const { data, error } = await supabase
                    .from('member_ratings')
                    .select('*');
                
                if (error) {
                    console.error('Error loading ratings:', error);
                    return;
                }
                
                // Update local ratings with database values
                if (data && data.length > 0) {
                    data.forEach(row => {
                        if (ratings[row.member_name]) {
                            ratings[row.member_name][row.category] = {
                                rating: row.rating,
                                rd: row.rd,
                                volatility: row.volatility
                            };
                        }
                    });
                    console.log(`✅ Loaded ${data.length} ratings from database`);
                }
            } catch (err) {
                console.error('Failed to load ratings:', err);
            }
        }

        // Save rating to Supabase
        async function saveRating(memberName, category, ratingData) {
            if (!supabase) {
                return; // Skip saving if Supabase not configured
            }
            
            try {
                const { error } = await supabase
                    .from('member_ratings')
                    .upsert({
                        member_name: memberName,
                        category: category,
                        rating: ratingData.rating,
                        rd: ratingData.rd,
                        volatility: ratingData.volatility,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'member_name,category'
                    });
                
                if (error) {
                    console.error('Error saving rating:', error);
                }
            } catch (err) {
                console.error('Failed to save rating:', err);
            }
        }

        const glicko = new Glicko2();
        let currentCategory = 'random';
        let currentPair = null;
        let selectedMember = null;
        let comparisonCounts = { rizz: 0, tizz: 0, freak: 0 };

        // Get random pair
        function getRandomPair() {
            const memberNames = Object.keys(members);
            const shuffled = memberNames.sort(() => 0.5 - Math.random());
            return [shuffled[0], shuffled[1]];
        }

        // Get actual category to use for this comparison
        function getActualCategory() {
            if (currentCategory === 'random') {
                const categories = ['rizz', 'tizz', 'freak'];
                return categories[Math.floor(Math.random() * categories.length)];
            }
            return currentCategory;
        }

        // Normalize rating to 0-1 scale
        function normalizeRating(rating) {
            // Glicko-2 ratings typically range from about 800-2200
            // We'll map this to 0-1
            const min = 800;
            const max = 2200;
            const normalized = (rating - min) / (max - min);
            return Math.max(0, Math.min(1, normalized)).toFixed(3);
        }

        // Animate score counting
        function animateScore(element, startScore, endScore, duration = 400) {
            const startValue = parseFloat(startScore);
            const endValue = parseFloat(endScore);
            const startTime = performance.now();
            
            function update(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth animation
                const easeProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                const currentValue = startValue + (endValue - startValue) * easeProgress;
                element.textContent = `Score: ${currentValue.toFixed(3)}`;
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            requestAnimationFrame(update);
        }

        // Display comparison
        function displayComparison() {
            currentPair = getRandomPair();
            selectedMember = null;
            const actualCategory = getActualCategory();
            
            const container = document.getElementById('comparisonContainer');
            
            // Preload images before displaying cards
            const imagePromises = currentPair.map(memberName => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve({ memberName, loaded: true });
                    img.onerror = () => resolve({ memberName, loaded: false }); // Resolve even on error to prevent hanging
                    img.src = members[memberName];
                });
            });
            
            // Wait for all images to load
            Promise.all(imagePromises).then(() => {
                container.innerHTML = '';
                
                currentPair.forEach(memberName => {
                    const rating = ratings[memberName][actualCategory];
                    const normalizedScore = normalizeRating(rating.rating);
                    
                    const card = document.createElement('div');
                    card.className = 'member-card';
                    card.dataset.member = memberName;
                    card.dataset.category = actualCategory; // Store the actual category being used
                    card.dataset.oldScore = normalizedScore; // Store the current score
                    card.innerHTML = `
                        <img src="${members[memberName]}" alt="${memberName}" class="member-image">
                        <div class="member-name">${memberName}</div>
                        <div class="member-score" style="visibility: hidden;">Score: ${normalizedScore}</div>
                        <div class="score-change"></div>
                    `;
                    
                    card.addEventListener('click', () => selectMember(memberName, actualCategory));
                    container.appendChild(card);
                });
            });

            // Update question for the actual category being compared
            updateQuestionForCategory(actualCategory);
        }

        // Select member
        async function selectMember(memberName, actualCategory) {
            if (selectedMember) return; // Already selected
            
            selectedMember = memberName;
            const winner = memberName;
            const loser = currentPair.find(m => m !== winner);

            // Disable further clicks
            const cards = document.querySelectorAll('.member-card');
            cards.forEach(card => {
                card.style.pointerEvents = 'none';
            });

            // First, show the original scores
            cards.forEach(card => {
                const member = card.dataset.member;
                const isWinner = member === winner;
                const scoreElement = card.querySelector('.member-score');
                const oldScore = card.dataset.oldScore;
                
                card.classList.add(isWinner ? 'selected' : 'not-selected');
                scoreElement.style.visibility = 'visible';
                scoreElement.textContent = `Score: ${oldScore}`;
            });

            // Wait 300ms, then update ratings and animate to new scores
            setTimeout(async () => {
                // Update ratings using Glicko-2
                const winnerOldRating = ratings[winner][actualCategory].rating;
                const loserOldRating = ratings[loser][actualCategory].rating;

                const winnerUpdate = glicko.updateRating(
                    ratings[winner][actualCategory].rating,
                    ratings[winner][actualCategory].rd,
                    ratings[winner][actualCategory].volatility,
                    [{ rating: ratings[loser][actualCategory].rating, rd: ratings[loser][actualCategory].rd }],
                    [1]
                );

                const loserUpdate = glicko.updateRating(
                    ratings[loser][actualCategory].rating,
                    ratings[loser][actualCategory].rd,
                    ratings[loser][actualCategory].volatility,
                    [{ rating: ratings[winner][actualCategory].rating, rd: ratings[winner][actualCategory].rd }],
                    [0]
                );

                ratings[winner][actualCategory] = winnerUpdate;
                ratings[loser][actualCategory] = loserUpdate;

                // Save updated ratings to Supabase
                await saveRating(winner, actualCategory, winnerUpdate);
                await saveRating(loser, actualCategory, loserUpdate);

                // Calculate changes
                const winnerChange = winnerUpdate.rating - winnerOldRating;
                const loserChange = loserUpdate.rating - loserOldRating;

                // Animate scores and update display
                cards.forEach(card => {
                    const member = card.dataset.member;
                    const isWinner = member === winner;
                    
                    const scoreElement = card.querySelector('.member-score');
                    const changeElement = card.querySelector('.score-change');
                    
                    const oldScore = card.dataset.oldScore;
                    const newScore = normalizeRating(ratings[member][actualCategory].rating);
                    const change = isWinner ? winnerChange : loserChange;
                    const normalizedChange = (change / 1400).toFixed(3); // Approximate normalization
                    
                    // Animate the score counting
                    animateScore(scoreElement, oldScore, newScore);
                    
                    // Show the change indicator
                    changeElement.className = `score-change ${isWinner ? 'score-increase' : 'score-decrease'}`;
                    changeElement.textContent = `${change > 0 ? '+' : ''}${normalizedChange}`;
                });

                comparisonCounts[actualCategory]++;
                updateComparisonCount();
                
                // Auto-advance after animation completes (400ms animation + 350ms buffer)
                setTimeout(() => {
                    displayComparison();
                }, 750);
            }, 300);
        }

        // Update comparison count
        function updateComparisonCount() {
            if (currentCategory === 'random') {
                const total = comparisonCounts.rizz + comparisonCounts.tizz + comparisonCounts.freak;
                document.getElementById('comparisonCount').textContent = 
                    `Total Comparisons: ${total} (Rizz: ${comparisonCounts.rizz}, Tizz: ${comparisonCounts.tizz}, Freak: ${comparisonCounts.freak})`;
            } else {
                document.getElementById('comparisonCount').textContent = 
                    `Comparisons (${currentCategory}): ${comparisonCounts[currentCategory]}`;
            }
        }

        // Update question text for a specific category
        function updateQuestionForCategory(category) {
            const categoryNames = {
                rizz: 'Rizz',
                tizz: 'Tizz',
                freak: 'Freak'
            };
            document.getElementById('question').textContent = 
                `Who has more ${categoryNames[category]}?`;
        }

        // Update question text based on current mode
        function updateQuestion() {
            if (currentCategory === 'random') {
                document.getElementById('question').textContent = 'Random Mode';
            } else {
                updateQuestionForCategory(currentCategory);
            }
        }

        // Category buttons
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentCategory = btn.dataset.category;
                updateQuestion();
                updateComparisonCount();
                displayComparison();
            });
        });

        // Skip button
        document.getElementById('skipBtn').addEventListener('click', displayComparison);

        // Initialize - load ratings then display
        async function initialize() {
            await loadRatings();
            updateQuestion();
            updateComparisonCount();
            displayComparison();
        }
        
        initialize();
    </script>
</body>
</html>
