<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTF Rankings</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 3em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .category-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .category-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            background: #e0e0e0;
            color: #333;
        }

        .category-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.05);
        }

        .category-btn:hover {
            transform: translateY(-2px);
        }

        .view-toggle {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .view-btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            background: #e0e0e0;
            color: #333;
        }

        .view-btn.active {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            transform: scale(1.05);
        }

        .view-btn:hover {
            transform: translateY(-2px);
        }

        .leaderboard-container {
            display: none;
        }

        .leaderboard-container.active {
            display: block;
        }

        .compare-container {
            display: none;
        }

        .compare-container.active {
            display: block;
        }

        .visualizer-container {
            display: none;
        }

        .visualizer-container.active {
            display: block;
        }

        .leaderboard-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .leaderboard-tab {
            padding: 10px 25px;
            border: none;
            border-radius: 20px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            background: #e0e0e0;
            color: #333;
        }

        .leaderboard-tab.active {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
        }

        .leaderboard-tab:hover {
            transform: translateY(-2px);
        }

        .leaderboard-table {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .leaderboard-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .leaderboard-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-size: 1.1em;
        }

        .leaderboard-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        .leaderboard-table tr:last-child td {
            border-bottom: none;
        }

        .leaderboard-table tr:hover {
            background: #f5f5f5;
        }

        .rank-cell {
            font-weight: bold;
            font-size: 1.2em;
            color: #667eea;
            width: 60px;
        }

        .name-cell {
            font-weight: 600;
            color: #333;
        }

        .score-cell {
            font-weight: bold;
            color: #4caf50;
            text-align: right;
            width: 100px;
        }

        .question {
            text-align: center;
            font-size: 1.8em;
            margin-bottom: 30px;
            color: #333;
            font-weight: 600;
        }

        .comparison-container {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .member-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            width: 280px;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .member-card:hover {
            transform: translateY(-10px);
            border-color: #667eea;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .member-card.selected {
            border-color: #4caf50;
            background: #f1f8e9;
        }

        .member-card.not-selected {
            border-color: #f44336;
            background: #ffebee;
        }

        .member-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .member-name {
            font-size: 1.4em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }

        .member-score {
            text-align: center;
            font-size: 1.2em;
            color: #667eea;
            font-weight: bold;
            margin-top: 10px;
        }

        .score-change {
            text-align: center;
            font-size: 1em;
            font-weight: bold;
            margin-top: 5px;
        }

        .score-increase {
            color: #4caf50;
        }

        .score-decrease {
            color: #f44336;
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .action-btn {
            padding: 15px 40px;
            border: none;
            border-radius: 25px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        #skipBtn {
            background: #e0e0e0;
            color: #333;
        }

        #skipBtn:hover {
            background: #d0d0d0;
        }

        #neitherBtn {
            background: linear-gradient(135deg, #f44336 0%, #e53935 100%);
            color: white;
        }

        #neitherBtn:hover {
            transform: scale(1.05);
        }

        .comparison-count {
            text-align: center;
            margin-top: 20px;
            font-size: 1.1em;
            color: #666;
        }

        /* 3D Visualizer Styles */
        #canvas-container {
            width: 100%;
            height: 600px;
            position: relative;
            background: #0a0e1a;
            border-radius: 15px;
            overflow: hidden;
        }

        #visualizer-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .visualizer-info {
            text-align: center;
            margin-top: 20px;
            color: #666;
            font-size: 0.95em;
        }

        .visualizer-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            background: #e0e0e0;
            color: #333;
        }

        .control-btn:hover {
            background: #d0d0d0;
            transform: translateY(-2px);
        }

        .tooltip-3d {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 14px;
            display: none;
            z-index: 1000;
            max-width: 250px;
        }

        .tooltip-3d.visible {
            display: block;
        }

        .tooltip-3d strong {
            color: #3399ff;
            display: block;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .tooltip-3d div {
            margin: 4px 0;
        }

        .selected-info-panel {
            background: #f5f5f5;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }

        .selected-info-panel.active {
            display: block;
        }

        .selected-info-content {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .selected-info-image {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            object-fit: cover;
        }

        .selected-info-details {
            flex: 1;
        }

        .selected-info-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .selected-info-scores {
            display: flex;
            gap: 15px;
            font-size: 0.95em;
            color: #666;
        }

        .selected-info-scores span {
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RTF Rankings</h1>

        <div class="view-toggle">
            <button class="view-btn active" data-view="compare">Compare Members</button>
            <button class="view-btn" data-view="leaderboard">Leaderboard</button>
            <button class="view-btn" data-view="visualizer">3D Visualizer</button>
        </div>

        <!-- Compare View -->
        <div id="compareView" class="compare-container active">
            <div class="category-selector">
                <button class="category-btn active" data-category="rizz">Rizz</button>
                <button class="category-btn" data-category="tizz">Tizz</button>
                <button class="category-btn" data-category="freak">Freak</button>
            </div>

            <div class="question" id="question">Loading...</div>

            <div id="comparisonContainer" class="comparison-container"></div>

            <div class="action-buttons">
                <button class="action-btn" id="skipBtn">Skip</button>
                <button class="action-btn" id="neitherBtn">Neither</button>
            </div>

            <div class="comparison-count" id="comparisonCount">Comparisons made: 0</div>
        </div>

        <!-- Leaderboard View -->
        <div id="leaderboardView" class="leaderboard-container">
            <div class="leaderboard-tabs">
                <button class="leaderboard-tab active" data-leaderboard="overall">Overall</button>
                <button class="leaderboard-tab" data-leaderboard="rizz">Rizz</button>
                <button class="leaderboard-tab" data-leaderboard="tizz">Tizz</button>
                <button class="leaderboard-tab" data-leaderboard="freak">Freak</button>
            </div>

            <div class="leaderboard-table" id="leaderboardTable"></div>
        </div>

        <!-- 3D Visualizer View -->
        <div id="visualizerView" class="visualizer-container">
            <div id="canvas-container">
                <canvas id="visualizer-canvas"></canvas>
                <div id="tooltip-3d" class="tooltip-3d"></div>
            </div>
            
            <div class="selected-info-panel" id="selectedInfoPanel">
                <div class="selected-info-content">
                    <img id="selectedImage" class="selected-info-image" src="" alt="">
                    <div class="selected-info-details">
                        <div class="selected-info-name" id="selectedName"></div>
                        <div class="selected-info-scores">
                            <div>Rizz: <span id="selectedRizz"></span></div>
                            <div>Tizz: <span id="selectedTizz"></span></div>
                            <div>Freak: <span id="selectedFreak"></span></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="visualizer-controls">
                <button class="control-btn" id="resetCameraBtn">Reset Camera ðŸŽ¥</button>
                <button class="control-btn" id="autoRotateBtn">Auto Rotate ðŸ”„</button>
            </div>

            <div class="visualizer-info">
                <strong>Interactive 3D Visualization</strong><br>
                Click and drag to rotate â€¢ Scroll to zoom â€¢ Click markers to select<br>
                X-axis: Rizz | Y-axis: Tizz | Z-axis: Freak
            </div>
        </div>
    </div>

    <script>
        // Supabase Configuration
        const SUPABASE_URL = 'https://cxytmlxqoficotadtmab.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN4eXRtbHhxb2ZpY290YWR0bWFiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MDcyMzksImV4cCI6MjA3ODM4MzIzOX0.Bx95F7ufVJmLUlJmwH4zvNdE5EmbGsD8GIwmMW0flbc';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        // Member data
        const members = {
            "Aiden Suganuma": "https://www.thecube.llc/static/media/aidensuganuma.3126d63249c98b402919.jpg",
            "Alex Boniske": "https://www.thecube.llc/static/media/alexboniske.c958ca550435720511aa.jpg",
            "Alexis Fox": "https://www.thecube.llc/static/media/alexisfox.9fddedf46775b7a836ca.jpg",
            "Avrick Altmann": "https://www.thecube.llc/static/media/avrickaltmann.2962baac481c96d2e2a3.jpg",
            "Brian Mason": "https://www.thecube.llc/static/media/brianmason.1d754f5b7455d04cb69d.jpg",
            "Brianna Yang": "https://www.thecube.llc/static/media/briannayang.b1a6cc543f582a9ed89f.jpg",
            "Claire Chang": "https://www.thecube.llc/static/media/clairechang.0ba7a8a19b6658fc97d4.jpg",
            "Jane Shin": "https://www.thecube.llc/static/media/janeshin.9c11a60627771be1c29c.jpg",
            "Jonah Stein": "https://www.thecube.llc/static/media/jonahstein.3b2666663214205c61a9.jpg",
            "Julia Chen": "https://www.thecube.llc/static/media/juliachen.3e523ce7d5d895f59168.jpg",
            "Paulina Vvedenskaya": "https://www.thecube.llc/static/media/paulinavvedenskaya.ad758ad986f8399743e7.jpg",
            "Rafael Soh": "https://www.thecube.llc/static/media/rafaelsoh.90dc2c640fb1455af0f9.jpg",
            "Rashmi Thapa": "https://www.thecube.llc/static/media/rashmithapa.1f8a2869f3728f81c5f0.jpg",
            "Sarthak Agrawal": "https://www.thecube.llc/static/media/sarthakagrawal.98becf14d552de9f748a.jpg",
            "Sarthak Dhawan": "https://www.thecube.llc/static/media/sarthakdhawan.cb8eb19a944daedbaf6e.jpg",
            "Thomas Hines": "https://www.thecube.llc/static/media/thomashines.8c6c95b7ff1aaf4761be.jpg",
            "Andri Kadaifciu": "https://www.thecube.llc/static/media/andrikadaifciu.e6ce027737160b390d5e.jpg",
            "Bilguun Zolzaya": "https://www.thecube.llc/static/media/bilguunzolzaya.85b87ad99f77588e0df1.jpg",
            "Brian Chen": "https://www.thecube.llc/static/media/brianchen.5862da7baff8f6d49e24.jpg",
            "Chloe Yang": "https://www.thecube.llc/static/media/chloeyang.103e0dc0e2317c85200e.jpg",
            "David Shenkerman": "https://www.thecube.llc/static/media/davidshenkerman.22ebe2a9aace6242b9e4.jpg",
            "Dhruva Barua": "https://www.thecube.llc/static/media/dhruvabarua.69420ae454b5d67f9e4b.jpg",
            "Evan Bulan": "https://www.thecube.llc/static/media/evanbulan.dee3aaa44b3b01832937.jpg",
            "Judy He": "https://www.thecube.llc/static/media/judyhe.44e9886e4b17e3840a2b.jpg",
            "Juliana Gates": "https://www.thecube.llc/static/media/julianagates.9f4911a90d03a8118b67.jpg",
            "Kartikeye Gupta": "https://www.thecube.llc/static/media/kartikeyegupta.6d81d7fa62376dd6ea68.jpg",
            "Kayla Liang": "https://www.thecube.llc/static/media/kaylaliang.f5d825fb70cc1289a0d6.jpg",
            "Kaylyn Zhong": "https://www.thecube.llc/static/media/kaylynzhong.82f7ccb726cfb79639cf.jpg",
            "Michelle Li": "https://www.thecube.llc/static/media/michelleli.371a405bace790d810e7.jpg",
            "Nikhil Pesaladinne": "https://www.thecube.llc/static/media/nikhilpesaladinne.5fe0b2660b878da2ff60.jpg",
            "Raphael Mukondiwa": "https://www.thecube.llc/static/media/raphaelmukondiwa.2d622fe8d1c290cc4034.jpg",
            "Sarah Tandon": "https://www.thecube.llc/static/media/sarahtandon.0f34021f85521a40eaf9.jpg",
            "Ting Ting Li": "https://www.thecube.llc/static/media/tingtingli.48df24abdb42b394cc2b.jpg",
            "Aaron Hsu": "https://www.thecube.llc/static/media/aaronhsu.2c939db0f8437be9aff3.jpg",
            "Anna Liu": "https://www.thecube.llc/static/media/annaliu.3d393ab8b322c834e47d.jpg",
            "Arvindh Manian": "https://www.thecube.llc/static/media/arvindhmanian.79c1ac445b9c2381b85e.jpg",
            "Aubteen Pour-Biazar": "https://www.thecube.llc/static/media/aubteenpour-biazar.2fe97968ea5340e786ed.jpg",
            "Ayush Jain": "https://www.thecube.llc/static/media/ayushjain.047dbf06730ab5a713fc.jpg",
            "Bill Ssewanyana": "https://www.thecube.llc/static/media/billssewanyana.6c45e1539bd4abea396e.jpg",
            "Divyansh Jain": "https://www.thecube.llc/static/media/divyanshjain.c896d81dfa744de4eaa6.jpg",
            "Eleanor Taylor": "https://www.thecube.llc/static/media/eleanortaylor.7cea9d66216289f8f304.jpg",
            "Hannah Choi": "https://www.thecube.llc/static/media/hannahchoi.1e663bbe71f35f8a5207.jpg",
            "John Buxton": "https://www.thecube.llc/static/media/johnbuxton.ce3d102780478f9f8f1a.jpg",
            "John Schappert": "https://www.thecube.llc/static/media/johnschappert.2cfb578d07ea4c8c74ba.jpg",
            "John Xu": "https://www.thecube.llc/static/media/johnxu.a2f51e78502b38b5fd49.jpg",
            "Kunling Tong": "https://www.thecube.llc/static/media/kunlingtong.1de16cae090c0e5f6f08.jpg",
            "Lasal Mapitigama": "https://www.thecube.llc/static/media/lasalmapitigama.9bd546f48653a7043337.jpg",
            "Nathan Shenkerman": "https://www.thecube.llc/static/media/nathanshenkerman.fb948bf1fbc207538a15.jpg",
            "Peter Liu": "https://www.thecube.llc/static/media/peterliu.3947d888af49b33d37a1.jpg",
            "Sophia Liu": "https://www.thecube.llc/static/media/sophialiu.d697baa2eb666bc8184c.jpg",
            "Taylor Moorehead": "https://www.thecube.llc/static/media/taylormoorehead.cc6d6987fecd991e5754.jpg",
            "Yura Heo": "https://www.thecube.llc/static/media/yuraheo.a04ed96ca10f8b4b03d4.jpg",
            "Aryan Mathur": "https://www.thecube.llc/static/media/aryanmathur.cc4031f997b4b70846e2.jpg",
            "Christian Okokhere": "https://www.thecube.llc/static/media/christianokokhere.95a6c04738cf781a6e62.jpg",
            "Holly Zhuang": "https://www.thecube.llc/static/media/hollyzhuang.cc0a66059d3e38390240.jpg",
            "Kasey Park": "https://www.thecube.llc/static/media/kaseypark.60d9451c439fe852d3fb.jpg",
            "N Wang": "https://www.thecube.llc/static/media/nwang.e0bb994957dd4c64be7d.jpg",
            "One Chowdhury": "https://www.thecube.llc/static/media/onechowdhury.4c6419c65cdb77cc82b3.jpg",
            "Pranay Vure": "https://www.thecube.llc/static/media/pranayvure.8fb7489f0f5e023e76df.jpg",
            "Richard Kim": "https://www.thecube.llc/static/media/richardkim.6a833178d95102a91634.jpg",
            "Aden Clemente": "https://www.thecube.llc/static/media/adenclemente.fc3aa2297d3914516876.jpg",
            "Athena Yao": "https://www.thecube.llc/static/media/athenayao.90600323a19baa053bad.jpg",
            "Clay Bromley": "https://www.thecube.llc/static/media/claybromley.bcc073e823955c7b5fc9.jpg",
            "Nils Roede": "https://www.thecube.llc/static/media/nilsroede.9903add37c3cb945a0d3.jpg"
        };

        // Initialize ratings for each member and category with Glicko-2 defaults
        let ratings = {};
        let comparisonCounts = { rizz: 0, tizz: 0, freak: 0 };
        let matchupHistory = { rizz: {}, tizz: {}, freak: {} };

        // Initialize ratings
        Object.keys(members).forEach(name => {
            ratings[name] = {
                rizz: { rating: 1500, rd: 350, volatility: 0.06 },
                tizz: { rating: 1500, rd: 350, volatility: 0.06 },
                freak: { rating: 1500, rd: 350, volatility: 0.06 }
            };
        });

        // Glicko-2 System Implementation
        class Glicko2 {
            constructor() {
                this.tau = 0.5; // System constant (volatility change)
                this.epsilon = 0.000001; // Convergence tolerance
            }

            // Convert rating to Glicko-2 scale
            scaleRating(rating) {
                return (rating - 1500) / 173.7178;
            }

            // Convert back to original scale
            unscaleRating(mu) {
                return mu * 173.7178 + 1500;
            }

            // Convert RD to Glicko-2 scale
            scaleRD(rd) {
                return rd / 173.7178;
            }

            // Convert back to original scale
            unscaleRD(phi) {
                return phi * 173.7178;
            }

            // g function
            g(phi) {
                return 1 / Math.sqrt(1 + 3 * phi * phi / (Math.PI * Math.PI));
            }

            // E function (expected score)
            E(mu, muJ, phiJ) {
                return 1 / (1 + Math.exp(-this.g(phiJ) * (mu - muJ)));
            }

            // Update rating after series of games
            updateRating(rating, rd, volatility, opponents, outcomes) {
                if (opponents.length === 0) return { rating, rd, volatility };

                const mu = this.scaleRating(rating);
                const phi = this.scaleRD(rd);
                const sigma = volatility;

                // Step 2: Calculate v (estimated variance)
                let v = 0;
                opponents.forEach(opp => {
                    const muJ = this.scaleRating(opp.rating);
                    const phiJ = this.scaleRD(opp.rd);
                    const gPhiJ = this.g(phiJ);
                    const EVal = this.E(mu, muJ, phiJ);
                    v += gPhiJ * gPhiJ * EVal * (1 - EVal);
                });
                v = 1 / v;

                // Step 3: Calculate delta
                let delta = 0;
                opponents.forEach((opp, i) => {
                    const muJ = this.scaleRating(opp.rating);
                    const phiJ = this.scaleRD(opp.rd);
                    const gPhiJ = this.g(phiJ);
                    const EVal = this.E(mu, muJ, phiJ);
                    delta += gPhiJ * (outcomes[i] - EVal);
                });
                delta *= v;

                // Step 4: Calculate new volatility
                const a = Math.log(sigma * sigma);
                const f = (x) => {
                    const ex = Math.exp(x);
                    const num = ex * (delta * delta - phi * phi - v - ex);
                    const denom = 2 * Math.pow(phi * phi + v + ex, 2);
                    return num / denom - (x - a) / (this.tau * this.tau);
                };

                let A = a;
                let B;
                if (delta * delta > phi * phi + v) {
                    B = Math.log(delta * delta - phi * phi - v);
                } else {
                    let k = 1;
                    while (f(a - k * this.tau) < 0) {
                        k++;
                    }
                    B = a - k * this.tau;
                }

                let fA = f(A);
                let fB = f(B);

                while (Math.abs(B - A) > this.epsilon) {
                    const C = A + (A - B) * fA / (fB - fA);
                    const fC = f(C);
                    if (fC * fB < 0) {
                        A = B;
                        fA = fB;
                    } else {
                        fA = fA / 2;
                    }
                    B = C;
                    fB = fC;
                }

                const sigmaNew = Math.exp(A / 2);

                // Step 5: Update rating and RD
                const phiStar = Math.sqrt(phi * phi + sigmaNew * sigmaNew);
                const phiNew = 1 / Math.sqrt(1 / (phiStar * phiStar) + 1 / v);
                const muNew = mu + phiNew * phiNew * opponents.reduce((sum, opp, i) => {
                    const muJ = this.scaleRating(opp.rating);
                    const phiJ = this.scaleRD(opp.rd);
                    const EVal = this.E(mu, muJ, phiJ);
                    return sum + this.g(phiJ) * (outcomes[i] - EVal);
                }, 0);

                return {
                    rating: this.unscaleRating(muNew),
                    rd: this.unscaleRD(phiNew),
                    volatility: sigmaNew
                };
            }
        }

        const glicko = new Glicko2();

        // Supabase functions
        async function loadRatings() {
            try {
                const { data, error } = await supabase
                    .from('member_ratings')
                    .select('*');
                
                if (error) throw error;
                
                if (data && data.length > 0) {
                    data.forEach(row => {
                        if (ratings[row.member_name]) {
                            ratings[row.member_name][row.category] = {
                                rating: row.rating,
                                rd: row.rd,
                                volatility: row.volatility
                            };
                        }
                    });
                    console.log(`âœ… Loaded ${data.length} ratings from database`);
                } else {
                    console.log('âœ… Connected to database - no existing ratings found, starting fresh');
                }
            } catch (error) {
                console.error('Error loading ratings:', error);
            }
        }

        async function saveRating(name, category, ratingData) {
            try {
                const { error } = await supabase
                    .from('member_ratings')
                    .upsert({
                        member_name: name,
                        category: category,
                        rating: ratingData.rating,
                        rd: ratingData.rd,
                        volatility: ratingData.volatility,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'member_name,category'
                    });
                
                if (error) throw error;
            } catch (error) {
                console.error('Error saving rating:', error);
            }
        }

        // Helper functions
        function normalizeRating(rating) {
            // Glicko-2 ratings typically range from about 800-2200
            // We'll map this to 0-100
            const min = 800;
            const max = 2200;
            const normalized = (rating - min) / (max - min) * 100;
            return Math.max(0, Math.min(100, normalized)); // Remove .toFixed(1) here
        }

        function recordMatchup(member1, member2, category) {
            const key = [member1, member2].sort().join('-');
            if (!matchupHistory[category][key]) {
                matchupHistory[category][key] = 0;
            }
            matchupHistory[category][key]++;
        }

        function getMatchupCount(member1, member2, category) {
            const key = [member1, member2].sort().join('-');
            return matchupHistory[category][key] || 0;
        }

        // Comparison logic
        let currentCategory = 'rizz';
        let currentPair = [];
        let selectedMember = null;

        function updateQuestion() {
            const questions = {
                rizz: "Who has more Rizz?",
                tizz: "Who has more Tizz?",
                freak: "Who is more of a Freak?"
            };
            document.getElementById('question').textContent = questions[currentCategory];
        }

        function updateComparisonCount() {
            const total = comparisonCounts.rizz + comparisonCounts.tizz + comparisonCounts.freak;
            document.getElementById('comparisonCount').textContent = 
                `Comparisons made: ${total} (Rizz: ${comparisonCounts.rizz}, Tizz: ${comparisonCounts.tizz}, Freak: ${comparisonCounts.freak})`;
        }

        function selectRandomPair() {
            const memberNames = Object.keys(members);
            const availablePairs = [];

            for (let i = 0; i < memberNames.length; i++) {
                for (let j = i + 1; j < memberNames.length; j++) {
                    const count = getMatchupCount(memberNames[i], memberNames[j], currentCategory);
                    availablePairs.push({
                        members: [memberNames[i], memberNames[j]],
                        count: count
                    });
                }
            }

            availablePairs.sort((a, b) => a.count - b.count);
            const minCount = availablePairs[0].count;
            const leastComparedPairs = availablePairs.filter(p => p.count === minCount);
            const randomPair = leastComparedPairs[Math.floor(Math.random() * leastComparedPairs.length)];
            
            return randomPair.members;
        }

        function animateScore(element, startValue, endValue, duration = 500) {
            const start = parseFloat(startValue);
            const end = parseFloat(endValue);
            const startTime = performance.now();
            
            function update(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const current = start + (end - start) * progress;
                element.textContent = `Score: ${current.toFixed(1)}`;
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            requestAnimationFrame(update);
        }

        async function handleSelection(winner) {
            if (selectedMember) return;
            
            selectedMember = winner;
            const actualCategory = document.querySelector('.member-card').dataset.category;
            const member1 = currentPair[0];
            const member2 = currentPair[1];
            const loser = winner === member1 ? member2 : member1;

            const cards = document.querySelectorAll('.member-card');
            cards.forEach(card => {
                card.style.pointerEvents = 'none';
                const member = card.dataset.member;
                const scoreElement = card.querySelector('.member-score');
                const oldScore = card.dataset.oldScore;
                
                if (member === winner) {
                    card.classList.add('selected');
                } else {
                    card.classList.add('not-selected');
                }
                
                scoreElement.style.visibility = 'visible';
                scoreElement.textContent = `Score: ${oldScore}`;
            });

            setTimeout(async () => {
                const winnerOldRating = ratings[winner][actualCategory].rating;
                const loserOldRating = ratings[loser][actualCategory].rating;

                const winnerUpdate = glicko.updateRating(
                    ratings[winner][actualCategory].rating,
                    ratings[winner][actualCategory].rd,
                    ratings[winner][actualCategory].volatility,
                    [{ rating: ratings[loser][actualCategory].rating, rd: ratings[loser][actualCategory].rd }],
                    [1]
                );

                const loserUpdate = glicko.updateRating(
                    ratings[loser][actualCategory].rating,
                    ratings[loser][actualCategory].rd,
                    ratings[loser][actualCategory].volatility,
                    [{ rating: ratings[winner][actualCategory].rating, rd: ratings[winner][actualCategory].rd }],
                    [0]
                );

                ratings[winner][actualCategory] = winnerUpdate;
                ratings[loser][actualCategory] = loserUpdate;

                recordMatchup(winner, loser, actualCategory);

                await saveRating(winner, actualCategory, winnerUpdate);
                await saveRating(loser, actualCategory, loserUpdate);

                const winnerChange = winnerUpdate.rating - winnerOldRating;
                const loserChange = loserUpdate.rating - loserOldRating;

                cards.forEach(card => {
                    const member = card.dataset.member;
                    const scoreElement = card.querySelector('.member-score');
                    const changeElement = card.querySelector('.score-change');
                    
                    const oldScore = card.dataset.oldScore;
                    const newScore = normalizeRating(ratings[member][actualCategory].rating);
                    const change = member === winner ? winnerChange : loserChange;
                    const normalizedChange = ((change / 1400) * 100).toFixed(1);
                    
                    animateScore(scoreElement, oldScore, newScore);
                    
                    changeElement.className = member === winner ? 'score-change score-increase' : 'score-change score-decrease';
                    changeElement.textContent = `${change > 0 ? '+' : ''}${normalizedChange}`;
                });

                comparisonCounts[actualCategory]++;
                updateComparisonCount();
                
                setTimeout(() => {
                    displayComparison();
                }, 750);
            }, 300);
        }

        function displayComparison() {
            selectedMember = null;
            currentPair = selectRandomPair();
            const container = document.getElementById('comparisonContainer');
            
            container.innerHTML = currentPair.map(name => {
                const score = normalizeRating(ratings[name][currentCategory].rating);
                return `
                    <div class="member-card" data-member="${name}" data-category="${currentCategory}" data-old-score="${score.toFixed(1)}">
                        <img src="${members[name]}" alt="${name}" class="member-image">
                        <div class="member-name">${name}</div>
                        <div class="member-score" style="visibility: hidden;">Score: ${score.toFixed(1)}</div>
                        <div class="score-change"></div>
                    </div>
                `;
            }).join('');

            document.querySelectorAll('.member-card').forEach(card => {
                card.addEventListener('click', () => {
                    handleSelection(card.dataset.member);
                });
            });
        }

        function calculateOverallScore(memberName) {
            const rizzScore = normalizeRating(ratings[memberName].rizz.rating);
            const tizzScore = normalizeRating(ratings[memberName].tizz.rating);
            const freakScore = normalizeRating(ratings[memberName].freak.rating);
            
            const magnitude = Math.sqrt(rizzScore * rizzScore + tizzScore * tizzScore + freakScore * freakScore);
            const maxMagnitude = Math.sqrt(100 * 100 + 100 * 100 + 100 * 100);
            return ((magnitude / maxMagnitude) * 100).toFixed(1);
        }

        function generateLeaderboard(category) {
            const memberNames = Object.keys(members);
            const leaderboardData = memberNames.map(name => {
                let score;
                if (category === 'overall') {
                    score = parseFloat(calculateOverallScore(name));
                } else {
                    score = parseFloat(normalizeRating(ratings[name][category].rating));
                }
                return { name, score };
            });

            leaderboardData.sort((a, b) => b.score - a.score);
            leaderboardData.forEach((entry, index) => {
                entry.rank = index + 1;
            });

            return leaderboardData;
        }

        function displayLeaderboard(category) {
            const leaderboardData = generateLeaderboard(category);
            const tableContainer = document.getElementById('leaderboardTable');
            
            const categoryNames = {
                overall: 'Overall',
                rizz: 'Rizz',
                tizz: 'Tizz',
                freak: 'Freak'
            };

            let html = `
                <table>
                    <thead>
                        <tr>
                            <th class="rank-cell">Rank</th>
                            <th class="name-cell">Name</th>
                            <th class="score-cell">${categoryNames[category]} Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            leaderboardData.forEach(entry => {
                html += `
                    <tr>
                        <td class="rank-cell">#${entry.rank}</td>
                        <td class="name-cell">${entry.name}</td>
                        <td class="score-cell">${entry.score.toFixed(1)}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            tableContainer.innerHTML = html;
        }

        // View toggle functionality
        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                document.getElementById('compareView').classList.remove('active');
                document.getElementById('leaderboardView').classList.remove('active');
                document.getElementById('visualizerView').classList.remove('active');
                
                if (view === 'compare') {
                    document.getElementById('compareView').classList.add('active');
                } else if (view === 'leaderboard') {
                    document.getElementById('leaderboardView').classList.add('active');
                    const activeTab = document.querySelector('.leaderboard-tab.active');
                    const category = activeTab ? activeTab.dataset.leaderboard : 'overall';
                    displayLeaderboard(category);
                } else if (view === 'visualizer') {
                    document.getElementById('visualizerView').classList.add('active');
                    init3DVisualizer();
                }
            });
        });

        // Leaderboard tab functionality
        document.querySelectorAll('.leaderboard-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const category = tab.dataset.leaderboard;
                
                document.querySelectorAll('.leaderboard-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                displayLeaderboard(category);
            });
        });

        // Category buttons
        document.querySelectorAll('.category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentCategory = btn.dataset.category;
                updateQuestion();
                updateComparisonCount();
                displayComparison();
            });
        });

        async function handleNeither() {
            if (selectedMember) return;
            
            selectedMember = 'neither';
            const actualCategory = document.querySelector('.member-card').dataset.category;
            const member1 = currentPair[0];
            const member2 = currentPair[1];

            const cards = document.querySelectorAll('.member-card');
            cards.forEach(card => {
                card.style.pointerEvents = 'none';
            });

            cards.forEach(card => {
                const scoreElement = card.querySelector('.member-score');
                const oldScore = card.dataset.oldScore;
                
                card.classList.add('not-selected');
                scoreElement.style.visibility = 'visible';
                scoreElement.textContent = `Score: ${oldScore}`;
            });

            setTimeout(async () => {
                const member1OldRating = ratings[member1][actualCategory].rating;
                const member2OldRating = ratings[member2][actualCategory].rating;

                const member1Update = glicko.updateRating(
                    ratings[member1][actualCategory].rating,
                    ratings[member1][actualCategory].rd,
                    ratings[member1][actualCategory].volatility,
                    [{ rating: ratings[member2][actualCategory].rating, rd: ratings[member2][actualCategory].rd }],
                    [0]
                );

                const member2Update = glicko.updateRating(
                    ratings[member2][actualCategory].rating,
                    ratings[member2][actualCategory].rd,
                    ratings[member2][actualCategory].volatility,
                    [{ rating: ratings[member1][actualCategory].rating, rd: ratings[member1][actualCategory].rd }],
                    [0]
                );

                ratings[member1][actualCategory] = member1Update;
                ratings[member2][actualCategory] = member2Update;

                recordMatchup(member1, member2, actualCategory);

                await saveRating(member1, actualCategory, member1Update);
                await saveRating(member2, actualCategory, member2Update);

                const member1Change = member1Update.rating - member1OldRating;
                const member2Change = member2Update.rating - member2OldRating;

                cards.forEach(card => {
                    const member = card.dataset.member;
                    
                    const scoreElement = card.querySelector('.member-score');
                    const changeElement = card.querySelector('.score-change');
                    
                    const oldScore = card.dataset.oldScore;
                    const newScore = normalizeRating(ratings[member][actualCategory].rating);
                    const change = member === member1 ? member1Change : member2Change;
                    const normalizedChange = ((change / 1400) * 100).toFixed(1);
                    
                    animateScore(scoreElement, oldScore, newScore);
                    
                    changeElement.className = 'score-change score-decrease';
                    changeElement.textContent = `${change > 0 ? '+' : ''}${normalizedChange}`;
                });

                comparisonCounts[actualCategory]++;
                updateComparisonCount();
                
                setTimeout(() => {
                    displayComparison();
                }, 750);
            }, 300);
        }

        document.getElementById('skipBtn').addEventListener('click', displayComparison);
        document.getElementById('neitherBtn').addEventListener('click', handleNeither);

        // 3D Visualizer
        let scene, camera, renderer, controls, markers = [];
        let hoveredMarker = null;
        let selectedMarker = null;
        let visualizerInitialized = false;
        let autoRotate = false;

        function normalizeToRange(value, inMin = 800, inMax = 2200, outMin = 0, outMax = 10) {
            const clamped = Math.max(inMin, Math.min(inMax, value));
            const normalized = (clamped - inMin) / (inMax - inMin);
            return normalized * (outMax - outMin) + outMin;
        }

        function init3DVisualizer() {
            if (visualizerInitialized) return;
            visualizerInitialized = true;

            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('visualizer-canvas');

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e1a);

            // Camera setup
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(12, 12, 18);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);

            // Axes helper
            const axesHelper = new THREE.AxesHelper(12);
            scene.add(axesHelper);

            // Grid helpers
            const gridXY = new THREE.GridHelper(12, 12, 0x888888, 0x222222);
            gridXY.rotation.x = Math.PI / 2;
            gridXY.position.set(6, 6, 0);
            scene.add(gridXY);

            const gridXZ = new THREE.GridHelper(12, 12, 0x666666, 0x111111);
            gridXZ.position.set(6, 0, 6);
            scene.add(gridXZ);

            const gridYZ = new THREE.GridHelper(12, 12, 0x666666, 0x111111);
            gridYZ.rotation.z = Math.PI / 2;
            gridYZ.position.set(0, 6, 6);
            scene.add(gridYZ);

            // Add axis labels
            createAxisLabels();

            // Create markers for each member
            createMarkers();

            // Mouse controls
            setupControls();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            animate();

            // Control buttons
            document.getElementById('resetCameraBtn').addEventListener('click', resetCamera);
            document.getElementById('autoRotateBtn').addEventListener('click', toggleAutoRotate);
        }

        function createAxisLabels() {
            const loader = new THREE.FontLoader();
            
            // For simplicity, we'll use sprites with canvas textures for labels
            function createTextSprite(text, color) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 128;
                
                context.fillStyle = color;
                context.font = 'Bold 48px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 128, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 1, 1);
                
                return sprite;
            }

            const rizzLabel = createTextSprite('Rizz â†’', '#79a1ff');
            rizzLabel.position.set(11.5, 0.3, 0);
            scene.add(rizzLabel);

            const tizzLabel = createTextSprite('Tizz â†’', '#79a1ff');
            tizzLabel.position.set(0, 11.5, 0);
            scene.add(tizzLabel);

            const freakLabel = createTextSprite('â† Freak', '#79a1ff');
            freakLabel.position.set(0, 0.3, 11.5);
            scene.add(freakLabel);
        }

        function createMarkers() {
            // Clear existing markers
            markers.forEach(m => scene.remove(m.group));
            markers = [];

            const memberNames = Object.keys(members);
            
            memberNames.forEach(name => {
                const rizzScore = ratings[name].rizz.rating;
                const tizzScore = ratings[name].tizz.rating;
                const freakScore = ratings[name].freak.rating;

                const x = normalizeToRange(rizzScore);
                const y = normalizeToRange(tizzScore);
                const z = normalizeToRange(freakScore);

                const group = new THREE.Group();
                
                // Inner sphere
                const innerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const innerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3399ff,
                    emissive: 0x3399ff,
                    emissiveIntensity: 0.4,
                    metalness: 0.1,
                    roughness: 0.3
                });
                const innerSphere = new THREE.Mesh(innerGeometry, innerMaterial);
                group.add(innerSphere);

                // Outer glow sphere
                const outerGeometry = new THREE.SphereGeometry(0.25, 16, 16);
                const outerMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3399ff,
                    transparent: true,
                    opacity: 0.14,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                const outerSphere = new THREE.Mesh(outerGeometry, outerMaterial);
                group.add(outerSphere);

                group.position.set(x, y, z);
                scene.add(group);

                markers.push({
                    name: name,
                    group: group,
                    innerSphere: innerSphere,
                    outerSphere: outerSphere,
                    innerMaterial: innerMaterial,
                    outerMaterial: outerMaterial,
                    rizz: normalizeRating(rizzScore),
                    tizz: normalizeRating(tizzScore),
                    freak: normalizeRating(freakScore)
                });
            });
        }

        function setupControls() {
            const canvas = document.getElementById('visualizer-canvas');
            const tooltip = document.getElementById('tooltip-3d');
            
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotationSpeed = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((e.clientX - rect.left) / rect.width) * 2 - 1,
                    -((e.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                let found = null;
                let minDist = Infinity;

                markers.forEach(marker => {
                    const distance = raycaster.ray.distanceToPoint(marker.group.position);
                    if (distance < 0.5 && distance < minDist) {
                        minDist = distance;
                        found = marker;
                    }
                });

                if (found && found !== hoveredMarker) {
                    if (hoveredMarker) resetMarkerColor(hoveredMarker);
                    hoveredMarker = found;
                    setMarkerColor(hoveredMarker, 0xff8800, 0.6, 0.26);
                    
                    tooltip.innerHTML = `
                        <strong>${found.name}</strong>
                        <div>Rizz: ${found.rizz.toFixed(1)}</div>
                        <div>Tizz: ${found.tizz.toFixed(1)}</div>
                        <div>Freak: ${found.freak.toFixed(1)}</div>
                    `;
                    tooltip.style.left = e.clientX - rect.left + 'px';
                    tooltip.style.top = e.clientY - rect.top + 'px';
                    tooltip.classList.add('visible');
                } else if (!found && hoveredMarker) {
                    if (hoveredMarker !== selectedMarker) resetMarkerColor(hoveredMarker);
                    hoveredMarker = null;
                    tooltip.classList.remove('visible');
                }

                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    rotationSpeed.y = deltaX * 0.005;
                    rotationSpeed.x = deltaY * 0.005;

                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationSpeed.y);
                    camera.position.applyAxisAngle(
                        new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion),
                        rotationSpeed.x
                    );
                    camera.lookAt(6, 6, 6);

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                if (hoveredMarker && hoveredMarker !== selectedMarker) {
                    resetMarkerColor(hoveredMarker);
                }
                hoveredMarker = null;
                tooltip.classList.remove('visible');
            });

            canvas.addEventListener('click', (e) => {
                if (hoveredMarker) {
                    if (selectedMarker) resetMarkerColor(selectedMarker);
                    selectedMarker = hoveredMarker;
                    setMarkerColor(selectedMarker, 0xffd700, 0.8, 0.32);
                    
                    // Update selected info panel
                    document.getElementById('selectedImage').src = members[selectedMarker.name];
                    document.getElementById('selectedName').textContent = selectedMarker.name;
                    document.getElementById('selectedRizz').textContent = selectedMarker.rizz.toFixed(1);
                    document.getElementById('selectedTizz').textContent = selectedMarker.tizz.toFixed(1);
                    document.getElementById('selectedFreak').textContent = selectedMarker.freak.toFixed(1);
                    document.getElementById('selectedInfoPanel').classList.add('active');
                }
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY * 0.01;
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, new THREE.Vector3(6, 6, 6)).normalize();
                camera.position.addScaledVector(direction, delta);
                
                const dist = camera.position.distanceTo(new THREE.Vector3(6, 6, 6));
                if (dist < 5) {
                    camera.position.subVectors(camera.position, new THREE.Vector3(6, 6, 6)).normalize().multiplyScalar(5).add(new THREE.Vector3(6, 6, 6));
                } else if (dist > 40) {
                    camera.position.subVectors(camera.position, new THREE.Vector3(6, 6, 6)).normalize().multiplyScalar(40).add(new THREE.Vector3(6, 6, 6));
                }
            });
        }

        function setMarkerColor(marker, color, emissiveIntensity, outerOpacity) {
            marker.innerMaterial.color.setHex(color);
            marker.innerMaterial.emissive.setHex(color);
            marker.innerMaterial.emissiveIntensity = emissiveIntensity;
            marker.outerMaterial.color.setHex(color);
            marker.outerMaterial.opacity = outerOpacity;
        }

        function resetMarkerColor(marker) {
            if (marker === selectedMarker) {
                setMarkerColor(marker, 0xffd700, 0.8, 0.32);
            } else {
                setMarkerColor(marker, 0x3399ff, 0.4, 0.14);
            }
        }

        function resetCamera() {
            camera.position.set(12, 12, 18);
            camera.lookAt(6, 6, 6);
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('autoRotateBtn');
            btn.textContent = autoRotate ? 'Stop Rotation ðŸ”„' : 'Auto Rotate ðŸ”„';
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate) {
                camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.005);
                camera.lookAt(6, 6, 6);
            }

            renderer.render(scene, camera);
        }

        // Initialize
        async function initialize() {
            try {
                await loadRatings();
            } catch (err) {
                console.error('Failed to load ratings, continuing with defaults:', err);
            }
            updateQuestion();
            updateComparisonCount();
            displayComparison();
        }
        
        initialize();
    </script>
</body>
</html>
